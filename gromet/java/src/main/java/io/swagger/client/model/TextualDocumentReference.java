/*
 * GroMEt Metadata spec
 * Grounded Model Exchange (GroMEt) Metadata schema specification  __Using Swagger to Generate Class Structure__  To automatically generate Python or Java models corresponding to this document, you can use [swagger-codegen](https://swagger.io/tools/swagger-codegen/). We can use this to generate client code based off of this spec that will also generate the class structure.  1. Install via the method described for your operating system    [here](https://github.com/swagger-api/swagger-codegen#Prerequisites).    Make sure to install a version after 3.0 that will support openapi 3. 2. Run swagger-codegen with the options in the example below.    The URL references where the yaml for this documentation is stored on    github. Make sure to replace CURRENT_VERSION with the correct version.    (The current version is `0.1.4`.)    To generate Java classes rather, change the `-l python` to `-l java`.    Change the value to the `-o` option to the desired output location.    ```    swagger-codegen generate -l python -o ./client -i https://raw.githubusercontent.com/ml4ai/automates-v2/master/docs/source/gromet_metadata_v{CURRENT_VERSION}.yaml    ``` 3. Once it executes, the client code will be generated at your specified    location.    For python, the classes will be located in    `$OUTPUT_PATH/swagger_client/models/`.    For java, they will be located in    `$OUTPUT_PATH/src/main/java/io/swagger/client/model/`  If generating GroMEt Metadata schema data model classes in SKEMA (AutoMATES), then afer generating the above, follow the instructions here: ``` <automates>/automates/model_assembly/gromet/metadata/README.md ``` 
 *
 * OpenAPI spec version: 0.1.4
 * Contact: claytonm@email.arizona.edu
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.client.model.Bibjson;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
/**
 * Document reference.
 */
@Schema(description = "Document reference.")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2022-10-09T12:36:06.656-07:00[America/Phoenix]")
public class TextualDocumentReference {
  @SerializedName("uid")
  private String uid = null;

  @SerializedName("global_reference_id")
  private String globalReferenceId = null;

  @SerializedName("cosmos_id")
  private String cosmosId = null;

  @SerializedName("cosmos_version_number")
  private String cosmosVersionNumber = null;

  @SerializedName("skema_id")
  private String skemaId = null;

  @SerializedName("skema_version_number")
  private String skemaVersionNumber = null;

  @SerializedName("bibjson")
  private Bibjson bibjson = null;

  public TextualDocumentReference uid(String uid) {
    this.uid = uid;
    return this;
  }

   /**
   * Unique identifier of the DocumentReference
   * @return uid
  **/
  @Schema(description = "Unique identifier of the DocumentReference")
  public String getUid() {
    return uid;
  }

  public void setUid(String uid) {
    this.uid = uid;
  }

  public TextualDocumentReference globalReferenceId(String globalReferenceId) {
    this.globalReferenceId = globalReferenceId;
    return this;
  }

   /**
   * Identifier of source document.&lt;br&gt; Rank preference of identifier type:&lt;br&gt; (1) DOI (digital object identifier) recognized by COSMOS&lt;br&gt; (2) PMID (Pubmed ID) or other DOI&lt;br&gt; (3) aske_id (ASKE unique identifier) 
   * @return globalReferenceId
  **/
  @Schema(description = "Identifier of source document.<br> Rank preference of identifier type:<br> (1) DOI (digital object identifier) recognized by COSMOS<br> (2) PMID (Pubmed ID) or other DOI<br> (3) aske_id (ASKE unique identifier) ")
  public String getGlobalReferenceId() {
    return globalReferenceId;
  }

  public void setGlobalReferenceId(String globalReferenceId) {
    this.globalReferenceId = globalReferenceId;
  }

  public TextualDocumentReference cosmosId(String cosmosId) {
    this.cosmosId = cosmosId;
    return this;
  }

   /**
   * ID of COSMOS component used to process document.
   * @return cosmosId
  **/
  @Schema(description = "ID of COSMOS component used to process document.")
  public String getCosmosId() {
    return cosmosId;
  }

  public void setCosmosId(String cosmosId) {
    this.cosmosId = cosmosId;
  }

  public TextualDocumentReference cosmosVersionNumber(String cosmosVersionNumber) {
    this.cosmosVersionNumber = cosmosVersionNumber;
    return this;
  }

   /**
   * Version number of COSMOS component.
   * @return cosmosVersionNumber
  **/
  @Schema(description = "Version number of COSMOS component.")
  public String getCosmosVersionNumber() {
    return cosmosVersionNumber;
  }

  public void setCosmosVersionNumber(String cosmosVersionNumber) {
    this.cosmosVersionNumber = cosmosVersionNumber;
  }

  public TextualDocumentReference skemaId(String skemaId) {
    this.skemaId = skemaId;
    return this;
  }

   /**
   * ID of SKEMA component used to process document.
   * @return skemaId
  **/
  @Schema(description = "ID of SKEMA component used to process document.")
  public String getSkemaId() {
    return skemaId;
  }

  public void setSkemaId(String skemaId) {
    this.skemaId = skemaId;
  }

  public TextualDocumentReference skemaVersionNumber(String skemaVersionNumber) {
    this.skemaVersionNumber = skemaVersionNumber;
    return this;
  }

   /**
   * Version number of SKEMA component.
   * @return skemaVersionNumber
  **/
  @Schema(description = "Version number of SKEMA component.")
  public String getSkemaVersionNumber() {
    return skemaVersionNumber;
  }

  public void setSkemaVersionNumber(String skemaVersionNumber) {
    this.skemaVersionNumber = skemaVersionNumber;
  }

  public TextualDocumentReference bibjson(Bibjson bibjson) {
    this.bibjson = bibjson;
    return this;
  }

   /**
   * Get bibjson
   * @return bibjson
  **/
  @Schema(description = "")
  public Bibjson getBibjson() {
    return bibjson;
  }

  public void setBibjson(Bibjson bibjson) {
    this.bibjson = bibjson;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TextualDocumentReference textualDocumentReference = (TextualDocumentReference) o;
    return Objects.equals(this.uid, textualDocumentReference.uid) &&
        Objects.equals(this.globalReferenceId, textualDocumentReference.globalReferenceId) &&
        Objects.equals(this.cosmosId, textualDocumentReference.cosmosId) &&
        Objects.equals(this.cosmosVersionNumber, textualDocumentReference.cosmosVersionNumber) &&
        Objects.equals(this.skemaId, textualDocumentReference.skemaId) &&
        Objects.equals(this.skemaVersionNumber, textualDocumentReference.skemaVersionNumber) &&
        Objects.equals(this.bibjson, textualDocumentReference.bibjson);
  }

  @Override
  public int hashCode() {
    return Objects.hash(uid, globalReferenceId, cosmosId, cosmosVersionNumber, skemaId, skemaVersionNumber, bibjson);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TextualDocumentReference {\n");
    
    sb.append("    uid: ").append(toIndentedString(uid)).append("\n");
    sb.append("    globalReferenceId: ").append(toIndentedString(globalReferenceId)).append("\n");
    sb.append("    cosmosId: ").append(toIndentedString(cosmosId)).append("\n");
    sb.append("    cosmosVersionNumber: ").append(toIndentedString(cosmosVersionNumber)).append("\n");
    sb.append("    skemaId: ").append(toIndentedString(skemaId)).append("\n");
    sb.append("    skemaVersionNumber: ").append(toIndentedString(skemaVersionNumber)).append("\n");
    sb.append("    bibjson: ").append(toIndentedString(bibjson)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
